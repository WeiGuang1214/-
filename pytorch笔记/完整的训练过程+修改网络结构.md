## 1、加载模型+预训练权重

```python
from torch import nn
vgg16_false = torchvision.models.vgg16(pretrained=False) # 不带预训练权重
vgg16_true = torchvision.models.vgg16(pretrained=True) # 带预训练权重

print(vgg16_true) # 可以查看网络的结构，层次
train_data = torchvision.datasets.CIFAR10('../data',train=True,transform=torchvision.transforms.ToTensor(),download=True) # 加载数据集
vgg16_true.add_module('add_linear',nn.Linear(1000,10)) # 添加层，参数对应维度

vgg16_true.classifier[6] = nn.Linear(4096,10) # 在classifier中修改层，参数对应维度
```



## 2、加载模型+保存模型

```python
from torch import nn
vgg16_false = torchvision.models.vgg16(pretrained=False) # 不带预训练权重
# 方式1 模型结构+参数
torch.save(vgg16_false,"vgg16_epoch1.pth") # save 保存模型和对应的权重

model = torch.load("vgg16_epoch1.pth") # load 加载模型和对应的权重

# 保存方式2，仅保存参数
torch.save(vgg16.state_dict(),"vgg16_epoch1.pth") # 把参数保存成字典

```

## 3、完整的训练+测试过程

```py
from torch import nn
# 加载数据集
train_data = torchvision.datasets.CIFAR10('../data',train=True,transform=torchvision.transforms.ToTensor(),download=True) # 加载数据集 并且转换数据集的类型
test_data = torchvision.datasets.CIFAR10('../data',train=False,transform=torchvision.transforms.ToTensor(),download=True) # 加载测试数据集

# 查看数据集情况
train_data_size = len(train_data)
print("训练数据集的长度：{}".fomate(train_data_size))

# 利用dataloader来加载数据集
train_dataloader = DataLoader(train_data,batch_size=64)
test_dataloader = DataLoader(test_data,batch_size=64)

# 搭建神经网络
class Tudeui(nn.Module):
    def __init__(self):
        super(Tudui,self).__init__()
        self.model = nn.Sequential(
        	nn.Conv2d(3,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,64,5,1,2),
            nn.Flatten(),
            nn.Linear(64*64,64),
            nn.Linear(64,10)
        )
    def forward(self,x):
        x = self.model(X)
        return x
if __name__ == '__main__':
	tudui = Tudui()    # 模型单独拿出去的时候可以不用if函数，直接新建一个tudui对象，然后使用这个模型
    # 损失函数
    loss_fn = nn.CrossEntropyLoss()
    # 优化器,lr也可以单独写出来
    optimizer = torch.optim.SGD(tudui.parameters(),lr=0.01)
    #记录训练网络的参数
    #记录训练的次数
    total_train_step = 0
    total_test_step = 0
    #训练轮数
    epoch = 10
    
    # 添加tensorboard 查看结果
    writer = SummaryWriter("../logs_train")
    
    for i in range(epoch):
        print("--第{}轮训练开始".fomate(i+1))
        
        # 训练开始
        for data in train_dataloader:
            imgs,targets = data
            outputs = tudui(imgs)
            loss = loss_fn(outputs,targets)
            # 优化器
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            total_train_step = total_train_step +1
            if total_train_step % 100 ==0:     # 百次的时候才打印训练记录
            	print("训练次数:{},Loss:{}".formate(total_train_step,loss.item())) # item把torch数据类型转换为数字
       			writer.add_scalar("train_loss",loss.item(),total_train_step)
    
        # 测试步骤
        # 求整个模型上的损失
        total_test_loss = 0
   	    with torch.no_grad():
            for data in test_dataloader:
                imgs,targets = data
                outputs = tuudi(imgs)
                loss = loss_fn(outputs,targets)
                total_test_loss += loss.item()
        print("整体数据集上的测试loss：{}".format(total_test_loss))
        writer.add_scalar("test_loss",total_test_loss,total_test_step)
        total_test_step += 1  
        
        torch.save(tudui,"tudui_{}.pth".format(i))  # 保存模型
        print("模型已保存")
writer.close()
```

![](https://github.com/WeiGuang1214/Study-Notes/blob/master/images/1730018643155.jpg)

