##### 文档注释

- ​	javadoc -d 文件夹名 -xx -yy Demo3.java

- ​	写在类之前，可以显示当前文档的相关信息

- ```java
  /**
  *@author XXX
  *@version 1.0
  */
  ```

- ​	相对路径：当前目录开始定位形成的一个路径

- ​	..\表示回到上一级

- ​	..\ ..\hello.java两个表示回到上两级

- ​	绝对路径：从根目录出发形成的路径

- ​	d:\abd\test.....\hello.java


##### DOS命令

- ​	dir	查看当前文件夹的文件

- ​	dir d:\xxx	查看当前具体文件夹里的文件

- ​	help cd 	查看当前指令的作用

- ​	cd /D c:	切换到其他盘

- ​	cd 相对路径或者绝对路径	切换到其他具体目录下

- ​	cd ..	切换到上一级

- ​	cd \	切换到根目录

- ​	tree	查看当前指定目录的所有子目录，目录树

- ​	cls	清屏

- ​	exit	退出DOS

- ​	md	创建目录

- ​	rd	删除目录

- ​	copy 拷贝文件

- ​	del 删除文件

- ​	echo 输入内容到文件

- ​	type	输入空文件

- ​	move	剪切


##### 数据类型

##### 引用数据类型：数组、类、接口

##### 基本数据类型：

- ​	byte 字节，一个字节8bit

- ​	int 4byte

- ​	short 2byte

- ​	long 8byte，500L，后面接L

- ​	float 4byte，浮点数=符号位+指数位+尾数位，尾数部分可能丢失，造成精度损失(小数都是近似值)，后面接f或者F

- ​	double float 8byte，

- ​	浮点数的计数方式有两种：十进制计数，一定要有小数点，5.1,5.10F，.512F，.512==0.512；

- ​	科学计数法：512E-2==512*10的-2次，521E2==52100，double / float和int计算还是float，特别重要：判断两个数是否相等，应该是两个数差值的绝对值小于10的-6，因为有可能存在误差

- ​	char 单个字符，char c1 = 'a';	char c2 = '\t';	char c3 = '飞';	char c4 = '85'；char类型可以加减，对应数值

- ​	A-Z是65-90

- ​	a-z是97-122

- ​	boolean 布尔，逻辑值，1byte，true or false


##### 数据类型自动转换：

- ​	小自动转大，自动转换类型：

- ​		char->int->long->float->double

- ​		byte->short->int->long->float->double

- ​		char和byte不能自动转换

- ​	大转小要强制转换：


​		

##### Java API文档

​	API是Java提供的基本编程接口，由Java自带的类还有相关的方法，中文在线文档：https：//www.matools.com；包里有接口、类、异常![image-20240718203857619](C:\Users\微光\AppData\Roaming\Typora\typora-user-images\image-20240718203857619.png)

##### 运算符

- 注意/前后的类型，      类似10/4=2,10.0/4=2.5

- -10 % 3= -1    a%b=a-a/b*b

- ##### 当a是小数时，a % b = a-(int)a  /b * b，小数运算是近似值

- 10% -3= 1  ，注意公式

- -10 % -3 = -1  ，可以理解为散列表向左向右，以0为中轴

- 自增，自减，i++，i--，++i，--i，注意独立使用和结合赋值使用的区别

- ##### 关系运算

- ==    !=  < >   <=   >=    instanceof  判断是否属于类的对象

- ##### 逻辑

- &&  ||    且，或

- &  逻辑与，作用和&&相同，但是前后都要判断，|  逻辑或，同样两边都要判断

- !a  非

- a ^ b    逻辑异或，ab不同的时候为true ，否则为false

- ##### 赋值

- == ，+= ，-=    复合赋值会进行类型强制转换，注意报错

- ##### 三元运算符

- result = a>b ? a++ : b-- ;	注意先处理返回 和 后计算表达式的运算	要注意类型的转换，三元不可以强制转换

- ##### 运算符的优先级

- 只有   单目运算、赋值运算  是从右往左	，其余都是从左往右

- ##### 运算顺序：

- 1、()   ,   {} 等

- 2、单目运算 ++ --

- 3、算术运算符

- 4、位移运算符 <<  >> >>> 

- 5、比较运算符

- 6、逻辑运算符

- 7、三元运算符

- 8、赋值运算符

- 先单目，再算术运算，再比较  再看逻辑大小


##### 标识符规范

​	驼峰命名，不能用关键字和保留字，注意特殊字符，

##### 输入

- java.util.Scanner 类

- Scanner scanner = new Scanner(System.in);

- String name = scanner.next() 字符串

- int a = scanner.nextInt() 什么类型就用什么结尾

- double salary = scanner.nextDouble() 什么类型就用什么结尾


#### 进制转换

- ##### 1、二、八、十六转十进制

- 存在0b开头，2：个位开始乘2的(位数-1)次方，求和

- 0开头八进制，8：个位开始乘8的(位数-1)次方，求和

- 0x开头十六进制，16：个位开始乘8的(位数-1)次方，求和

- ##### 2、十进制转二、八、十六

- 除余再整除，保留余数，逆置就是进制转换结果

- 0b

- 0

- 0x

- ##### 3、二进制转八、十六进制

- 2转8：从低位开始每三个数一组，转成对应10进制即可，最后数排起来就是8进制

- 2转16：从低位开始每四个数一组，转成对应10进制即可，最后数排起来就是16进制

- ##### 4、八、十六进制转二进制

- 8转2：每一位转成3位2进制

- 16转2：每一位转成4位2进制

- ##### 位运算

- ##### 二进制最重要的第一位是符号位，0是正，1是负

- ##### 正数的原码、反码、补码都一样，三码合一

- 负数求反码，负号位不变，其余的求反码

- 负数的补码=反码+1

- 负数的反码=补码-1

- 0的反码补码都是0

- 右移>>：移动几位，除以2的几次方，整除形式

- 左移<<：移动几位，乘以2的几次方

- 无符号右移>>>：

- ##### 这四则运算都是先转换为补码再运算

- ~按位取反：0变1,1变0，正数的反码是其本身，*负数的反码是符号位保持不变*，其余位取反

- &按位与：每位每位的对比，同时为1结果为1，否则为0

- |按位或：至少有一个1结果为1，否则为0

- ^按位异或：两个一个为0一个为1，否则为0

- ##### 结果返回要转换为原码（最后print为10进制），注意负号的情况


##### 顺序控制

- 分支控制 if

- 双分支 if else、嵌套

- 多分支switch：


```java
switch(表达式):{  //表达式只能是 byte int short char string enum[]
    case '常量1':
    	语句块1;
    	break;  //  有退出的时候，匹配了退出，否则没有匹配，继续往后判断
    // 如果匹配了没有break，会一直执行后面的语句块，default也会执行，直到break   穿透
    case '常量2':
    	语句块2: 
    	break; 
    default:  // 如果前面没有匹配就默认执行，然后break，可有可无
    	语句块;
    	break;
}
```

- 需要注意的是表达式和case后的常量类型一致或者可以相互转换，char->int，case后必须常量，加 ' '

- ##### for循环  

- for(int i = 0;i<100;i++){     //   ；；为死循环

- }   // i++可以写入循环体内，i的作用域在循环体内也有效

- ##### while循环

- while(条件){

- 循环体

- }

- ##### do while循环。dowhile是关键字

- do先会执行一次，不论循环对错都会执行一次

- do{

- }while(条件);

- 循环条件返回的是布尔值的表达式

- ##### 多重循环控制，嵌套，注意内外变量

- ##### break跳出循环  continue 继续下一次循环

- break可以利用标签label指明要终结的是哪一层循环


```java
label1:
for(int j =0;j<4;j++){
label2:
	for(){
		if(){
			break label1;
		}
	}
} //break到哪，推出到哪个label
```

- 没有label默认退出最近的循环

- ##### return 返回值，或return;，表示跳出所在的方法，如果在main里面return就是结束程序

- ##### 数组，数组是引用类型，类型是Object


##### 动态初始化，数组初始化没赋值都是类型的默认值

- 1、类型 名字[] = new 类型[大小]   int a[] = new int[10];    数组名[下标]  a[2]  从0开始
- 2、先声明，再new一个，先声明再创建   int a[];   a[] = new[10];

- 3、静态初始化，直接赋值，下标越界会报错

##### 数组赋值机制，数组复制是引用，传递的是地址，地址传递的修改会修改原本的数据结构

​	int a1[] = {1,2,3};  int a2[] = a1;，不修改值的拷贝是for循环复制

##### JVM的内存：栈、堆、方法区

- 数组的翻转，原地换位

- 数组动态(利用do while，复制给一个大一位的数组)、静态扩容


##### 数组应用：排序、查找、栈、队列、顺序存储

- 二维数组

- ```java
  for (int i=0;i<a.length;i++){
              for (int j=0;j<a[i].length;j++){
    //二维数组  第一维长度：a.length  ，第二维长度：a[i].length
              }
          }
  ```

- 动态初始化：int a //[ ]//[ ] = new int //[2]//[3]

- 二维数组，一维的a[]其实是存的数组名，a//[]//[]为二维数组的值，地址取值方式

- a指向的是数组首地址，以此类推

- 动态定义：int a//[]/[];  ，再new  a = new int [2]//[3] 


##### 类与对象

​	类class .属性，.方法     生成对象  ，调用属性方法

```java
class AA{

	String aaa;
	基本数据类型、引用、数组、类的对象
	int num;
}
AA xiaoa = new AA()
xiaoa.aaa=
xiaoa.num=
```

#### 方法

- ##### 访问修饰符

- public   protected   默认  private

- 类的对象开辟空间

- ##### Java 内存的结构分析

- 1、栈：存储基本的数据类型，局部变量

- 2、堆：存放对象，数组等

- 3、方法区：常量池、类加载信息

- 创建流程：先加载类信息(属性和方法)，在堆中开辟空间默认初始化，把地址返回给对象，进行指定初始化

- ##### 成员方法

- 类里面定义，对象调用，程序执行到方法才开辟空间，注意方法返回值，输入参数

- ##### 访问修饰符控制方法的访问范围 public  private  默认不写  protected

- 方法只能有一个返回值，方法参数传值，数组等等引用类型，传递的是地址，可以修改到具体变量

- ##### 递归，注意递归出口，递归条件

- ##### 方法的重载

- ##### 	重载的前提是方法名相同，允许多个同名方法存在，但是形参列表，重点是参数类型、参数个数、顺序不能一样，对方法的修饰符、返回类型无要求

#### 可变参数

- 允许把同一类中多个同名同功能但参数个数不同的方法，封装成一个方法，可以通过可变参数实现

- int...表示类型int的0-多个参数，nums可以当可变场数组，实参可以是数组，可变参数就是数组，可以通过下标访问全部参数，可变参数可以和普通参数写在一起，但是可变参数一定要放在最后，一个形参列表最多只能一个可变参数

- ```java
  public int sum(int... nums){
  
  }
  ```

- 全局变量（类内属性,默认初始化），局部变量（方法内，需要初始化）的作用域

- 全局变量可以用访问控制符修饰，但是局部变量不可以

#### 构造方法/构造器，对新对象的初始化

- 构造器的修饰符可以默认，也可以随意，
- 构造器没有返回值
- 方法名必须和类名一致
- 构造器的调用是由系统完成的
- 构造器也能重载
- 系统有无参默认的构造器，自己定义也可以无参构造器
- 对象创建的流程，栈、堆、方法区
- 注意无参构造器中嵌套有参构造器this()
- ##### this关键字

​	Java虚拟机给每个对象分配this，代表当前对象，this.name=name，this.hashCode可以简单看成内部地址，哪个对象调用，this就代表哪个对象，this只能在构造器中使用，可以在一个构造器中访问另外一个构造器，this可以直接使用构造器，this()，里面赋值传参

#### 面向对象编程

- **IDEA快捷键：**

  - **ctrl +d 删除行**
  - **ctrl+alt+向下光标  复制当前行**
  - **alt+/ 补全代码**
  - **ctrl+/ 添加注释，再按取消**
  - **导入改行需要的类，alt+enter**
  - **快速格式化，ctrl+shift+L**
  - **快速运行程序，自己定义 ctrl+r**
  - **生成构造器等 alt+insert**
  - **查看类的层级关系   ctrl+H**
  - **定位到哪个类的方法  ctrl+B** 
  - **自动分配变量名    .var**     例：new Scanner(System.in).var

- 包

  - package 包名;  打包，import导入包，管理类，package只能放在第一句
  - 命名规则：数字、字母、下划线、小圆点，但是不能数字开头且关键字、保留字     ：   公司名.项目名.模块名
  - 基本包，自动导入：java.lang.*
  - 工具包：java.util.*
  - 网络包：java.net.*
  - GUI界面开发：java.awt.*

- ##### 访问修饰符

  - public  对外公开
  - protected 子类和同一个包中的类公开
  - 默认 没有修饰符，对同类、同包公开
  - private 私有，只有类本身访问
  - 只有默认和public可以修饰类


- ##### 封装

  - 把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，在程序的其他部分通过被授权的方法操作属性
  - 隐藏实现细节、可以对数据进行验证，保证安全合理
  - 实现封装：
    - 属性私有化，private，外部不能修改
    - 公共set方法，用于对属性判断并且赋值，将构造器和set方法结合在一起写
    - 提供一个公共get方法，用于获得属性的值

- ##### 继承

  - 解决代码复用，降低冗余，从父类中定义相同的属性和方法，用子类extends继承父类即可使用属性和方法
  - class 子 extends 父{}
  - **子类继承所有属性和方法，但是私有属性不能在子类直接访问，但是可以通过父类的公共方法访问**
  - 子类必须首先调用父类的无参构造器，完成父类的初始化，如果父类没有无参构造器，就要用super关键字指定用父类哪个构造器构造，super(参数列表)
  - super()在构造器中只能放在第一行，并且super()和this()不能同时存在一个构造器中
  - Java所有类都是Object的子类，只能单继承
  - 父类的构造器调用不限于父类，可能一直调用祖先的构造器

- ##### super关键字

  - super代表父类的引用，用于访问父类的属性、方法和构造器
  - 父类属性：super.属性，但是不能访问私有属性
  - 父类方法：super.方法，但是不能访问私有方法
  - 构造器：super(参数列表 )


- ##### 方法重写/覆盖   override

  子类继承父类的方法后重写父类的方法，定义的形式一样：名称、返回类型、参数列表一样

  - 子类不能缩小父类的访问权限
  - 方法重写/覆盖   override

- #### 多态

  - 多态建立在封装和继承的基础上-->两个(对象)类有继承关系
  - 方法的多态：重写和重载
  - 对象的多态(核心)：
    - 对象的编译类型和运行类型可以不一致
    - 编译类型在定义对象的时候就确定了，不能改变
    - 运行类型是可以变的
    - 编译类型看定义=左边，运行类型看=右边，属性的值只看编译类型，方法的调用看运行类型
  - **多态：向上转型**
    - 父类的引用指向子类的对象     父类  引用名 = new 子类()
    - 可以调用父类的所有成员，遵守(遵守访问权限)，不可以调用子类的特有成员，因为在编译阶段能调用的成员是由编译类型决定，
  - **多态：向下转型**
    - 子类的引用指向父类的对象   子类  引用名 = (子类类型)父类引用，强制转换引用，地址一样
    - 只能强转父类的引用，不能强制转换父类的对象
    - 可以调用子类类型中所有的成员
    - 要求父类的引用必须指向的是当前目标类型的对象
    - 属性没有重写之说，属性的值只看编译类型
    - instanceOf  判断xx运行类型是否属于x类型或者子类型   a  instanceOf  b  true or false

- #### **Java动态绑定机制**

  
  - 当调用对象方法的时候，该方法会和对象的内存、运行类型绑定
  
  - 当调用对象属性的时候，没有动态绑定机制，哪里声明(当前类)，哪里使用
  
- #### 多态数组

  - 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型，编辑类型是父类，运行类型实际根据JVM来
  - 如何调用子类特有的方法，比如Teacher对象，统一放在数组中，调用每个对象的say

- #### 多态参数

  - 方法定义的形参类型为父类类型，实参类型允许为子类类型

#### Java动态绑定机制

- 













​	

























